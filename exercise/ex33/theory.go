package ex33

import (
	"fmt"
	"time"
)

// Вот и подошло время познакомиться с самой сильной стороной языка Go — горутинами. Горутины — это легковесные потоки, которые реализуют конкурентное программирование в Go. Их называют легковесными потоками, потому что они управляются рантаймом языка, а не операционной системой. Стоимость переключения контекста и расход памяти намного ниже, чем у потоков ОС. Следовательно, для Go — не проблема поддерживать одновременно десятки тысяч горутин.
// Запустить функцию в горутине — супер легко. Для этого достаточно написать слово go перед вызовом функции:
func main() {
	// выведет сообщение в горутине
	go fmt.Println("Hello concurrent world")

	// если не подождать, то программа закончится, не успев, вывести сообщение
	time.Sleep(100 * time.Millisecond)
}

// При написании конкурентного кода возникают новые моменты, которые нужно учитывать: состояние гонки, блокировки, коммуникация между горутинами. Пример программы, которая работает не так, как ожидается:
func main2() {
	for i := 0; i < 5; i++ {
		go func() {
			fmt.Println(i)
		}()
	}

	time.Sleep(100 * time.Millisecond)
}

// Сперва может показаться, что должны вывестись числа от 0 до 4, но на самом деле вывод будет следующим:
//5
//5
//5
//5
//5

// Все потому что i передается в общем скоупе, следовательно, когда горутины будут выполняться, цикл уже закончится и i будет равно 5. В данном случае нужно передать копию i:
func main3() {
	for i := 0; i < 5; i++ {
		go func(i int) {
			fmt.Println(i)
		}(i)
	}

	time.Sleep(100 * time.Millisecond)
}

// Вывод:
//0
//4
//3
//1
//2
// Также можно заметить, что числа вывелись не в порядке вызова. Горутины выполняются независимо и не гарантируют порядка. При необходимости последовательность в выполнении придется реализовывать самостоятельно.
