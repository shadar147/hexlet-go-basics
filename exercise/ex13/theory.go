package ex13

import "fmt"

func main() {
	// Массив — это коллекция однотипных значений фиксированной длины:
	//nums := [5]int{}

	// Длина массива указывается в квадратных скобках. Если не заполнить массив при инициализации, то массив будет состоять из нулевых значений данного типа:
	//nums := [5]int{} // [0, 0, 0, 0, 0]

	// длинная инициализация
	//var nums [5]int // [0, 0, 0, 0, 0]

	// При попытке инициализации элементов за границей массива выходит ошибка компиляции:
	//nums := [1]int{1, 2} // array index 1 out of bounds [0:1]

	// Чтение и запись элементов массива происходит через квадратные скобки:
	numbers := [3]int{1, 2, 3}

	fmt.Println(numbers[1]) // 2

	numbers[2] = 33

	fmt.Println(numbers) // [1, 2, 33]

	// Нумерация элементов массива начинается с 0. При попытке чтения/записи элементов за границей массива выходит ошибка компиляции:
	//words := [2]string{}

	//fmt.Println(words[2]) // invalid array index 2 (out of bounds for 2-element array)

	// Массивы в Go передаются по значению, следовательно, любое изменение внутри функции не влияет на исходный массив:
	a := [3]int{1, 2, 3}

	modifyArr(a)

	fmt.Println(a) // 1, 2, 3

	// В Go есть встроенная функция len(), которая возвращает длину массива:
	fmt.Println(len([5]int{1, 2, 3})) // 5
	fmt.Println(len([10]int{}))       // 10

	// Так как массивы инициализируются с фиксированной длинной, то функция len() всегда возвращает одно и то же значение.
}

func modifyArr(nums [3]int) {
	nums[0] = 35
}
